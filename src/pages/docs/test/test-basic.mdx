---
layout: "/layout.astro"
---

# Test basic

- **Ubicacion**: es mejor que los test esten en la misma carpeta que el codigo que se esta probando
- **Nombre**: el nombre del archivo debe terminar con `.test.ts` o `.spec.ts`

<h3>
	<g-emoji
		class="g-emoji"
		alias="open_file_folder"
		fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c2.png"
	>
		
	</g-emoji>{" "}
	record
</h3>
<ul>
	<li>
		И <code>diff-object.test.ts</code>
	</li>
	<li>
		 <code>diff-object.ts</code>
	</li>
	<li>
		 <code>index.ts</code>
	</li>
	<li>
		И <code>is-record-empty.test.ts</code>
	</li>
	<li>
		 <code>is-record-empty.ts</code>
	</li>
	<li>
		И <code>is-record.test.ts</code>
	</li>
	<li>
		 <code>is-record.ts</code>
	</li>
	<li>
		 <code>with.ts</code> 
	</li>
</ul>

## Excluir de la compilaci贸n de TypeScript

Para evitar que TypeScript compile los archivos de test, puedes agregar una entrada en el archivo `tsconfig.json`:

```json
{
	"compilerOptions": {
		// otras opciones...
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "**/*.test.ts", "**/*.spec.ts"]
}
```

# Test-Driven Development

Test-Driven Development (TDD) o Desarrollo Dirigido por Pruebas es una pr谩ctica de desarrollo de software que implica escribir pruebas automatizadas antes de escribir el c贸digo que se est谩 desarrollando.

El proceso de TDD se puede resumir en los siguientes pasos:

1. **Escribir una prueba**: se escribe una prueba que cubre una funcionalidad espec铆fica del c贸digo que se va a desarrollar.
2. **La prueba falla**: se ejecuta la prueba y, como no hay c贸digo que la satisfaga, la prueba falla.
3. **Escribir el c贸digo**: se escribe el c贸digo m铆nimo necesario para que la prueba pase.
4. **La prueba pasa**: se ejecuta la prueba y, si el c贸digo es correcto, la prueba pasa.
5. **Refactorizar**: se refactoriza el c贸digo para que sea m谩s limpio, eficiente y f谩cil de mantener.
6. **Repetir**: se repite el proceso para la siguiente funcionalidad o requisito.

El objetivo de TDD es asegurarse de que el c贸digo sea correcto, fiable y f谩cil de mantener. Al escribir pruebas antes de escribir el c贸digo, se garantiza que el c贸digo sea testeable y que se cubran todos los casos posibles.

### Example

- describor la funcionalidad que quiero probar

```ts
import { describe, test } from "vitest";

describe("fizzbuzz", () => {
  test("given a number divisible by 3, should return Fizz");
  test("given a number divisible by 5, should return Buzz");
  test("given a number divisible by 3 AND 5, should return FizzBuzz");
  test("given a number not divisible by 3 or 5, should return the number");
});
```

- Escribimos el test antes de escribir el codigo que vamos a probar

```ts
import { describe, test } from "vitest";
import { fizzbuzz } from "./fizzbuzz";

describe("fizzbuzz", () => {
  test("given a number divisible by 3, should return Fizz", () => {
    const result = fizzbuzz(3);
    expect(result).toBe("Fizz");
  });
})

```

- ejecutamos el test con `npm run test`
- vemos fallar el test
- escribimos lo minimo necesario para que el test pase

```ts
export function fizzbuzz(number: number){
  retunr "Fizz";
}
```
- cuando el test pasa, podemos seguir con el siguiente test

```ts
export function fizzbuzz(value: number){
    if(value % 3 === 0 && value % 5 === 0){
        return "FizzBuzz";
    }
    if(value % 3 === 0){
        return "Fizz";
    }
    if(value % 5 === 0){
        return "Buzz";
    }
    return value;
}
```
- elminamos duplicados
- refactorizamos

```ts
export function fizzbuzz(value: number) {
	const isDivisibleBy3 = value % 3 === 0;
	const isDivisibleBy5 = value % 5 === 0;

	if (isDivisibleBy3 && isDivisibleBy5) {
		return "FizzBuzz";
	}
	if (isDivisibleBy3) {
		return "Fizz";
	}
	if (isDivisibleBy5) {
		return "Buzz";
	}
	return value;
}

```
