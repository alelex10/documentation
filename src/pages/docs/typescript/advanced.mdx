---
layout: "/layout.astro"
---

## 1. üõ†Ô∏è Utility Types

Los Utility Types son tipos predefinidos en TypeScript que nos permiten transformar y manipular otros tipos de manera eficiente. Son herramientas poderosas que nos ayudan a crear c√≥digo m√°s flexible y reutilizable.

### üìã Partial`<T>`

Convierte todas las propiedades de un tipo en opcionales.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// Todas las propiedades se vuelven opcionales
type PartialUser = Partial<User>;

// Equivale a:
// {
//   id?: number;
//   name?: string;
//   email?: string;
//   age?: number;
// }

function updateUser(id: number, updates: Partial<User>) {
  // Podemos actualizar solo algunas propiedades
  console.log(`Actualizando usuario ${id}`, updates);
}

updateUser(1, { name: "Juan Carlos" }); // Solo actualiza el nombre
updateUser(2, { email: "nuevo@email.com", age: 30 }); // Actualiza email y edad
```

**Important Considerations:**

- `Partial<T>` es extremadamente √∫til cuando se trata de operaciones de actualizaci√≥n donde es posible que solo desees modificar un subconjunto de las propiedades de un objeto.
- Al hacer que todas las propiedades sean opcionales, evitas tener que proporcionar valores predeterminados o manejar individualmente las propiedades que podr√≠an faltar. Esto puede conducir a un c√≥digo m√°s limpio y f√°cil de mantener.

## üîí Required`<T>`

Convierte todas las propiedades opcionales de un tipo en requeridas.

```ts
interface UserConfig {
  theme?: string;
  language?: string;
  notifications?: boolean;
}

type RequiredUserConfig = Required<UserConfig>;

// Equivale a:
// {
//   theme: string;
//   language: string;
//   notifications: boolean;
// }

function validateConfig(config: Required<UserConfig>) {
  // Todas las propiedades son obligatorias aqu√≠
  console.log(config.theme); // No hay riesgo de undefined
  console.log(config.language);
  console.log(config.notifications);
}
```

## üõ†Ô∏è Utility Types en TypeScript

TypeScript ofrece varios Utility Types que facilitan la manipulaci√≥n y transformaci√≥n de tipos. Aqu√≠ tienes algunos de los m√°s √∫tiles:

### üéØ Pick`<T, K>`

Crea un nuevo tipo seleccionando solo propiedades espec√≠ficas de un tipo existente.

```typescript
interface Product {
  id: number;
  name: string;
  description: string;
  price: number;
  category: string;
  inStock: boolean;
}

// Solo seleccionamos las propiedades que necesitamos
type ProductSummary = Pick<Product, "id" | "name" | "price">;

// Equivale a:
// {
//   id: number;
//   name: string;
//   price: number;
// }

function displayProductCard(product: ProductSummary) {
  return `${product.name} - $${product.price}`;
}
```

### üö´ Omit`<T, K>`

Crea un nuevo tipo excluyendo propiedades espec√≠ficas de un tipo existente.

```typescript
interface Employee {
  id: number;
  name: string;
  email: string;
  salary: number;
  department: string;
}

// Excluimos informaci√≥n sensible
type PublicEmployee = Omit<Employee, "salary">;

// Equivale a:
// {
//   id: number;
//   name: string;
//   email: string;
//   department: string;
// }

function getPublicEmployeeInfo(employee: Employee): PublicEmployee {
  const { salary, ...publicInfo } = employee;
  return publicInfo;
}
```

### üìù Record`<K, T>`

Crea un tipo con propiedades de tipo `K` y valores de tipo `T`.

```typescript
// Crear un diccionario con claves string y valores number
type StatusCodes = Record<string, number>;

const httpCodes: StatusCodes = {
  OK: 200,
  NOT_FOUND: 404,
  SERVER_ERROR: 500,
};

// Usar con tipos m√°s espec√≠ficos
type Theme = "light" | "dark" | "auto";
type ThemeConfig = Record<Theme, { background: string; text: string }>;

const themeSettings: ThemeConfig = {
  light: { background: "#ffffff", text: "#000000" },
  dark: { background: "#000000", text: "#ffffff" },
  auto: { background: "system", text: "system" },
};
```

### üîó Otros Utility Types √∫tiles

- `Exclude<T, U>` - Excluye tipos de una uni√≥n.
  ```typescript
  type Colors = "red" | "green" | "blue" | "yellow";
  type PrimaryColors = Exclude<Colors, "yellow">; // 'red' | 'green' | 'blue'
  ```
- `Extract<T, U>` - Extrae tipos de una uni√≥n.
  ```typescript
  type ExtractedColors = Extract<Colors, "red" | "blue">; // 'red' | 'blue'
  ```
- `NonNullable<T>` - Excluye `null` y `undefined`.
  ```typescript
  type MaybeString = string | null | undefined;
  type DefinitelyString = NonNullable<MaybeString>; // string
  ```
- `ReturnType<T>` - Obtiene el tipo de retorno de una funci√≥n.
  ```typescript
  function getUser() {
    return { id: 1, name: "Juan" };
  }
  type UserReturnType = ReturnType<typeof getUser>; // { id: number; name: string; }
  ```

## Extraer tipos de una `Promise<string>`

```typescript
type PromiseType = Promise<string>;

type ResultType = Awaited<PromiseType>;
// ResultType es string
```

# Enum en TypeScript

¬°Claro! Este es un patr√≥n muy com√∫n y √∫til en TypeScript para crear un conjunto de constantes y derivar un tipo a partir de ellas.

Vamos a analizarlo en dos partes:

### 1. El Objeto Constante

```typescript
const TaskStatus = {
  TODO: "todo",
  IN_PROGRESS: "in-progress",
  DONE: "done",
} as const;
```

- Se crea un objeto JavaScript llamado `TaskStatus`.
- El `as const` al final es la parte clave. Es una "aserci√≥n de const" de TypeScript que le dice al compilador dos cosas:
  1.  Que las propiedades del objeto (`TODO`, `IN_PROGRESS`, `DONE`) sean de solo lectura (`readonly`).
  2.  Que infiera los tipos m√°s espec√≠ficos posibles. En lugar de que el tipo de `TaskStatus.TODO` sea `string`, ser√° el tipo literal `"todo"`.

Gracias a `as const`, TypeScript entiende que el objeto `TaskStatus` tiene este tipo exacto:

```typescript
{
    readonly TODO: "todo";
    readonly IN_PROGRESS: "in-progress";
    readonly DONE: "done";
}
```

### 2. El Tipo Derivado

```typescript
type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];
```

Aqu√≠ es donde ocurre la "magia" para crear el tipo. Desglosemos la parte derecha:

- `typeof TaskStatus`: Obtiene el **tipo** del objeto `TaskStatus` que definimos antes.
- `keyof typeof TaskStatus`: Obtiene una uni√≥n de todas las **claves** (keys) de ese tipo. El resultado es: `"TODO" | "IN_PROGRESS" | "DONE"`.
- `( ... )[ ... ]`: Esto se conoce como "indexed access type". Es como acceder a los valores de un objeto, pero a nivel de tipos.

Al combinar todo, le estamos pidiendo a TypeScript: "Dame un tipo que sea una uni√≥n de los tipos de todos los **valores** del objeto `TaskStatus`".

El resultado final es que el `type TaskStatus` se convierte en:

```typescript
type TaskStatus = "todo" | "in-progress" | "done";
```

### ¬øPor qu√© es √∫til este patr√≥n?

Es una forma de tener una **√∫nica fuente de verdad**.

1.  **En tiempo de ejecuci√≥n**, usas el objeto: `if (myTask.status === TaskStatus.IN_PROGRESS)`.
2.  **En tiempo de compilaci√≥n**, usas el tipo para asegurar que solo se usen valores v√°lidos: `function updateTask(status: TaskStatus) { ... }`.

Si en el futuro necesitas a√±adir un nuevo estado, como `ARCHIVED`, solo tienes que modificar el objeto:

```typescript
const TaskStatus = {
  TODO: "todo",
  IN_PROGRESS: "in-progress",
  DONE: "done",
  ARCHIVED: "archived", // <-- Nuevo estado
} as const;

// El tipo TaskStatus se actualiza autom√°ticamente a:
// "todo" | "in-progress" | "done" | "archived"
// ¬°No necesitas cambiar nada m√°s!
```

Esto hace que tu c√≥digo sea m√°s f√°cil de mantener y menos propenso a errores.

# Intersecci√≥n de tipos

```typescript
type User = {
  id: number;
  name: string;
};
type Admin = {
  role: string;
};

type AdminUser = User & Admin;

const admin: AdminUser = {
  id: 1,
  name: "Santiago",
  role: "superadmin",
};
```

# Tipos Condicionales

```typescript
type IsString<T> = T extends any[] ? T[number] : T;

```
