---
layout: "/layout.astro"
---

# 1. üåê Introducci√≥n a WebSockets

**WebSockets** es un **protocolo de comunicaci√≥n** que permite establecer una **conexi√≥n bidireccional persistente** entre el **cliente** y el **servidor** sobre una **√∫nica conexi√≥n TCP**. Esto significa que una vez que se establece la conexi√≥n, ambos extremos pueden **enviar y recibir datos** en cualquier momento, sin necesidad de realizar **solicitudes HTTP** adicionales como ocurre en el modelo tradicional.

En el **modelo HTTP**, cada petici√≥n del cliente requiere una respuesta del servidor, y cada intercambio implica abrir y cerrar la conexi√≥n (a menos que se utilice **HTTP Keep-Alive**). **WebSockets** elimina esta fricci√≥n al mantener una **conexi√≥n viva**, lo cual permite una **comunicaci√≥n en tiempo real** m√°s fluida y eficiente.

Esta tecnolog√≠a es particularmente √∫til en aplicaciones modernas que demandan **inmediatez**, **interactividad** y **sincronizaci√≥n continua de datos**.

### ‚ú® Caracter√≠sticas principales

- `socket`: el socket sera cada conexi√≥n individual entre el cliente y el servidor.
- **`Fallback autom√°tico`**: Si **`WebSockets`** no est√° disponible (por ejemplo, en redes corporativas con firewalls restrictivos), **`Socket.IO`** utiliza otros transportes como **`HTTP long-polling`** para garantizar la conectividad.
- **`Reconexi√≥n autom√°tica`**: Si se pierde la conexi√≥n, **`Socket.IO`** intenta reconectar al cliente de forma autom√°tica, lo que mejora la resiliencia.
- **`Salas (Rooms)`**: Permite agrupar clientes en ‚Äúsalas‚Äù para enviar mensajes a subconjuntos espec√≠ficos.
- **`Middlewares`**: Se pueden definir funciones intermedias para procesar o validar datos antes de ejecutar la l√≥gica principal (ideal para autenticaci√≥n o logging).
- **`Eventos personalizados`**: Permite definir eventos sem√°nticos espec√≠ficos para cada acci√≥n, facilitando la organizaci√≥n del c√≥digo y su mantenimiento.

### üÜö Socket.IO vs WebSockets nativos

**`WebSocket` nativo**

```javascript
const ws = new WebSocket("ws://localhost:3000");
ws.onmessage = (event) => {
  console.log("Mensaje recibido:", event.data);
};
ws.send("Hola servidor");
```

**`Socket.IO`**

```javascript
const socket = io("http://localhost:3000");
socket.on("mensaje_personalizado", (data) => {
  console.log("Mensaje recibido:", data);
});
socket.emit("enviar_mensaje", { texto: "Hola servidor" });
```

Como se puede observar, **`Socket.IO`** provee una interfaz m√°s intuitiva y robusta que incluye nombres de eventos, soporte para reconexi√≥n, y mecanismos de agrupamiento que **`WebSockets`** por s√≠ solos no proporcionan.

### üöÄ Configuraci√≥n inicial en NestJS

#### üì¶ Instalaci√≥n de dependencias

```shell
pnpm add @nestjs/websockets @nestjs/platform-socket.io socket.io
pnpm add -D @types/socket.io
```

#### ‚öôÔ∏è Configuraci√≥n b√°sica del m√≥dulo

```typescript src/app.module.ts
// app.module.ts
import { Module } from "@nestjs/common";
import { ChatGateway } from "./chat/chat.gateway";

@Module({
  providers: [ChatGateway],
})
export class AppModule {}
```

### üåü Gateways en NestJS

Los **`Gateways`** son clases que manejan las conexiones **`WebSocket`** en NestJS. Son similares a los controladores pero para comunicaci√≥n en tiempo real.

#### Generar Gateway con CLI

```shell
nest generate gateway name-del-gateway
```

#### üìá Estructura b√°sica de un Gateway

- **`@WebSocketServer()`**: Inyecta la instancia del servidor **`Socket.IO`**.
- **`@SubscribeMessage('evento')`**: Define un manejador para un evento espec√≠fico. Este decorador se aplica a un m√©todo dentro de tu `Gateway`. Cuando un cliente env√≠a un mensaje con el nombre de evento 'evento', el m√©todo decorado se ejecutar√° autom√°ticamente, recibiendo los datos enviados por el cliente como argumento. La funci√≥n puede retornar un objeto `WsResponse`, que se utiliza para enviar una respuesta de vuelta al cliente que origin√≥ el mensaje.
- **`handleConnection(client)`**: M√©todo que se ejecuta cuando un cliente se conecta.
- **`handleDisconnect(client)`**: M√©todo que se ejecuta cuando un cliente se desconecta.
- **`handleMessage(client, data)`**: M√©todo que se ejecuta cuando un cliente envia un mensaje.

```typescript src/chat/chat.gateway.ts
// chat.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayInit,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from "@nestjs/websockets";
import { Server, Socket } from "socket.io";

@WebSocketGateway({
  cors: {
    origin: "*", // En producci√≥n, especifica dominios espec√≠ficos
  },
})
export class ChatGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server: Server;

  afterInit(server: Server) {
    console.log("Gateway inicializado");
  }

  handleConnection(client: Socket) {
    console.log(`Cliente conectado: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Cliente desconectado: ${client.id}`);
  }

  @SubscribeMessage("message")
  handleMessage(client: Socket, payload: any): string {
    return "Mensaje recibido en el servidor";
  }
}
```

#### üîß Decoradores principales

- **`@WebSocketGateway(options?)`**: Marca una clase como **`Gateway`** y permite configurar opciones:

  ```typescript
  @WebSocketGateway({
    port: 3001,
    namespace: '/chat',
    cors: {
      origin: ['http://localhost:3000', 'https://miapp.com'],
      credentials: true,
    },
  })
  ```

- **`@WebSocketServer()`**: Inyecta la instancia del servidor **`Socket.IO`**:

  ```typescript
  @WebSocketServer()
  server: Server;
  ```

- **`@SubscribeMessage('evento')`**: Define manejadores para eventos espec√≠ficos:
  ```typescript
  @SubscribeMessage('chat_message')
  handleChatMessage(client: Socket, data: { message: string; user: string }) {
    return { status: 'success', timestamp: new Date() };
  }
  ```
  ### üåê Cliente JavaScript (ejemplo)
- ¬øPor que usa ``http`` antes de ``ws``?
  - Porque **`Socket.IO`** maneja autom√°ticamente la reconexi√≥n y el fallback a otros transportes si **`WebSockets`** no est√° disponible.
- para poder usar sockedio desde el cliente, debes incluir la librer√≠a de **`Socket.IO`** en tu proyecto. Puedes hacerlo a trav√©s de un [CDN](https://socket.io/docs/v4/client-installation/#from-a-cdn) o [instal√°ndola con npm](https://socket.io/docs/v4/client-installation/#from-npm).

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat WebSocket</title>
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>
```

```javascript
// conectarse al servidor
const socket = io('http://localhost:3000');

// Unirse a una sala
socket.emit('join_room', {
  username: 'Santiago',
  room: 'general'
});

// Enviar mensaje
function sendMessage() {
  const message = document.getElementById('messageInput').value;
  socket.emit('send_message', { message });
  document.getElementById('messageInput').value = '';
}

// Escuchar nuevos mensajes
socket.on('new_message', (data) => {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML += `
      <div>
          <strong>${data.user}:</strong> ${data.message}
          <small>(${new Date(data.timestamp).toLocaleTimeString()})</small>
      </div>
  `;
});

// Escuchar usuarios que se conectan
socket.on('user_joined', (data) => {
  console.log(data.message);
});

// Escuchar errores
socket.on('error', (data) => {
  console.error('Error:', data.message);
});
```